//! High-level client interface for interacting with the CodeDefender SaaS API.
//!
//! This module provides functions to upload files, analyze binaries, initiate
//! obfuscation, and poll for obfuscation results via blocking HTTP requests.
//!
//! All endpoints require a valid API key, passed via the `Authorization` header
//! using the `ApiKey` scheme.
use codedefender_config::{AnalysisResult, Config};
use reqwest::{StatusCode, blocking::Client};
use std::collections::HashMap;
use once_cell::sync::Lazy;
pub use codedefender_config;
pub use serde_json;

/// Changing the BASE_URL env variable allows you to specify a different backend like staging or local.
pub static BASE_URL: Lazy<String> = Lazy::new(|| {
    std::env::var("BASE_URL").unwrap_or_else(|_| "https://app.codedefender.io".into())
});

pub static GET_UPLOAD_URL_EP: Lazy<String> =
    Lazy::new(|| format!("{}/api/get-upload-url", *BASE_URL));
pub static ANALYZE_EP: Lazy<String> =
    Lazy::new(|| format!("{}/api/analyze", *BASE_URL));
pub static ANALYZE_STATUS_EP: Lazy<String> =
    Lazy::new(|| format!("{}/api/analyze-status", *BASE_URL));
pub static DEFEND_EP: Lazy<String> =
    Lazy::new(|| format!("{}/api/defend", *BASE_URL));
pub static DOWNLOAD_EP: Lazy<String> =
    Lazy::new(|| format!("{}/api/download", *BASE_URL));

pub enum Status {
    Ready(String),
    Processing,
}

/// Gets the presigned upload URL and file ID for uploading a file.
///
/// # Arguments
///
/// * `file_size` - The size of the file to upload in bytes.
/// * `file_name` - Optional custom file name. If provided, it will be used; otherwise, a random UUID will be generated by the server.
/// * `client` - A preconfigured `reqwest::blocking::Client`.
/// * `api_key` - Your CodeDefender API key.
///
/// # Returns
///
/// A tuple containing the file ID and presigned upload URL.
///
/// # Panics
///
/// Panics if the request fails or if the server responds with a non-success status code, with a descriptive message.
pub fn get_upload_info(
    file_size: usize,
    file_name: Option<String>,
    client: &Client,
    api_key: &str,
) -> (String, String) {
    let mut query_params = HashMap::new();
    query_params.insert("fileSize".to_string(), file_size.to_string());
    if let Some(name) = file_name {
        query_params.insert("fileName".to_string(), name);
    }
    let response = client
        .get(&*GET_UPLOAD_URL_EP)
        .header("Authorization", format!("ApiKey {}", api_key))
        .query(&query_params)
        .send()
        .expect("Failed to send request to get upload URL")
        .error_for_status()
        .expect("Non-success status when getting upload URL");
    let json: HashMap<String, String> = response.json().expect("Failed to parse JSON response for upload info");
    let upload_url = json.get("uploadUrl").cloned().expect("Missing 'uploadUrl' in response");
    let file_id = json.get("fileId").cloned().expect("Missing 'fileId' in response");
    (file_id, upload_url)
}
/// Uploads file bytes to the presigned S3 URL.
///
/// # Arguments
///
/// * `upload_url` - The presigned S3 upload URL.
/// * `file_bytes` - The raw contents of the file to upload.
/// * `client` - A preconfigured `reqwest::blocking::Client`.
///
/// # Panics
///
/// Panics if the upload fails or the server responds with a non-success status code, with a descriptive message.
pub fn upload_to_s3(
    upload_url: &str,
    file_bytes: Vec<u8>,
    client: &Client,
) {
    client
        .put(upload_url)
        .header("Content-Type", "application/octet-stream")
        .header("Content-Length", file_bytes.len().to_string())
        .body(file_bytes)
        .send()
        .expect("Failed to send upload request to S3")
        .error_for_status()
        .expect("Non-success status when uploading to S3");
}
/// Uploads raw data bytes to CodeDefender with a specific filename and returns the file ID.
///
/// # Arguments
///
/// * `data` - The raw bytes to upload.
/// * `filename` - The specific filename to use for the upload.
/// * `client` - A preconfigured `reqwest::blocking::Client`.
/// * `api_key` - Your CodeDefender API key.
///
/// # Returns
///
/// The file ID.
///
/// # Panics
///
/// Panics if the request fails or if the server responds with a non-success status code, with a descriptive message.
pub fn upload_data(
    data: Vec<u8>,
    filename: String,
    client: &Client,
    api_key: &str,
) -> String {
    let file_size = data.len();
    let (file_id, upload_url) = get_upload_info(file_size, Some(filename), client, api_key);
    upload_to_s3(&upload_url, data, client);
    file_id
}
/// Uploads a binary file to CodeDefender and returns a UUID representing the uploaded file.
///
/// # Arguments
///
/// * `file_bytes` - The raw contents of the binary file to upload.
/// * `client` - A preconfigured `reqwest::blocking::Client`.
/// * `api_key` - Your CodeDefender API key.
///
/// # Returns
///
/// The UUID.
///
/// # Panics
///
/// Panics if the upload fails or if the server responds with a non-success status code, with a descriptive message.
pub fn upload_file(
    file_bytes: Vec<u8>,
    client: &Client,
    api_key: &str,
) -> String {
    let file_size = file_bytes.len();
    let (file_id, upload_url) = get_upload_info(file_size, None, client, api_key);
    upload_to_s3(&upload_url, file_bytes, client);
    file_id
}
/// Starts analysis of a previously uploaded binary file and optionally its PDB file.
///
/// # Arguments
///
/// * `file_id` - UUID of the uploaded binary file.
/// * `pdb_file_id` - Optional UUID of the associated PDB file.
/// * `client` - A preconfigured `reqwest::blocking::Client`.
/// * `api_key` - Your CodeDefender API key.
///
/// # Returns
///
/// The execution ID for polling.
///
/// # Panics
///
/// Panics if the request fails or the server responds with a non-success status, with a descriptive message.
pub fn start_analyze(
    file_id: String,
    pdb_file_id: Option<String>,
    client: &Client,
    api_key: &str,
) -> String {
    let mut query_params = HashMap::new();
    query_params.insert("fileId".to_string(), file_id);
    if let Some(pdb_id) = pdb_file_id {
        query_params.insert("pdbFileId".to_string(), pdb_id);
    }
    let response = client
        .put(&*ANALYZE_EP)
        .header("Authorization", format!("ApiKey {}", api_key))
        .query(&query_params)
        .send()
        .expect("Failed to send request to start analysis")
        .error_for_status()
        .expect("Non-success status when starting analysis");
    let json: HashMap<String, String> = response.json().expect("Failed to parse JSON response for analysis start");
    let execution_id = json
        .get("executionId")
        .cloned()
        .expect("Missing 'executionId' in response");
    execution_id
}
/// Polls the analysis status.
///
/// This endpoint should be called periodically until the analysis is complete.
///
/// # Arguments
///
/// * `execution_id` - The execution ID returned by [`start_analyze`].
/// * `client` - A preconfigured `reqwest::blocking::Client`.
/// * `api_key` - Your CodeDefender API key.
///
/// # Returns
///
/// A [`Status`] enum indicating whether the analysis is ready (with presigned URL) or still processing.
///
/// # Panics
///
/// Panics if the request fails, the server responds with a non-success status, or required fields are missing, with a descriptive message.
pub fn get_analyze_status(execution_id: String, client: &Client, api_key: &str) -> Status {
    let mut query_params = HashMap::new();
    query_params.insert("executionId".to_string(), execution_id);
    let resp = client
        .get(&*ANALYZE_STATUS_EP)
        .header("Authorization", format!("ApiKey {}", api_key))
        .query(&query_params)
        .send()
        .expect("Failed to send request for analysis status");
    let status = resp.status();
    if status == StatusCode::ACCEPTED {
        Status::Processing
    } else if status == StatusCode::OK {
        let json: serde_json::Value = resp.json().expect("Failed to parse JSON for analysis status");
        let value = json["analysisUrl"].as_str().expect("Missing 'analysisUrl' in response");
        Status::Ready(value.to_string())
    } else {
        panic!("Unexpected status code when getting analysis status: {}", status);
    }
}
/// Downloads and deserializes the analysis result from the presigned URL.
///
/// # Arguments
///
/// * `analysis_url` - The presigned URL returned by [`get_analyze_status`] when ready.
/// * `client` - A preconfigured `reqwest::blocking::Client`.
///
/// # Returns
///
/// An `AnalysisResult` containing metadata about the uploaded binary.
///
/// # Panics
///
/// Panics if the download fails, the server responds with a non-success status, or deserialization fails, with a descriptive message.
pub fn download_analysis_result(
    analysis_url: &str,
    client: &Client,
) -> AnalysisResult {
    let response = client.get(analysis_url).send().expect("Failed to send request to download analysis result")
        .error_for_status().expect("Non-success status when downloading analysis result");
    let result_bytes = response.bytes().expect("Failed to read bytes from analysis response");
    let analysis_result: AnalysisResult = serde_json::from_slice(&result_bytes).expect("Failed to deserialize analysis result");
    analysis_result
}
/// Starts the obfuscation process for a given file using the provided configuration.
///
/// # Arguments
///
/// * `uuid` - UUID of the uploaded binary file (not the PDB).
/// * `config` - Obfuscation configuration as a `CDConfig`.
/// * `client` - A preconfigured `reqwest::blocking::Client`.
/// * `api_key` - Your CodeDefender API key.
///
/// # Returns
///
/// The `execution_id` used for polling.
///
/// # Panics
///
/// Panics if the request fails or the server returns a non-success status, with a descriptive message.
pub fn defend(
    uuid: String,
    config: Config,
    client: &Client,
    api_key: &str,
) -> String {
    let body = serde_json::to_string(&config).expect("Failed to serialize Config");
    let mut query_params = HashMap::new();
    query_params.insert("fileId", uuid);
    let response = client
        .post(&*DEFEND_EP)
        .header("Authorization", format!("ApiKey {}", api_key))
        .header("Content-Type", "application/json")
        .query(&query_params)
        .body(body)
        .send()
        .expect("Failed to send request to start obfuscation")
        .error_for_status()
        .expect("Non-success status when starting obfuscation");
    response.text().expect("Failed to read text from obfuscation start response")
}
/// Polls the obfuscation status.
///
/// This endpoint should be called every 500 milliseconds until the obfuscation is complete.
///
/// ⚠️ Note: This endpoint is rate-limited to **200 requests per minute**.
///
/// # Arguments
///
/// * `execution_id` - The execution ID returned by [`defend`].
/// * `client` - A preconfigured `reqwest::blocking::Client`.
/// * `api_key` - Your CodeDefender API key.
///
/// # Returns
///
/// A [`Status`] enum indicating whether the file is ready (with presigned URL) or still processing.
///
/// # Panics
///
/// Panics if the request fails, the server responds with a non-success status, or required fields are missing, with a descriptive message.
pub fn download(execution_id: String, client: &Client, api_key: &str) -> Status {
    let mut query_params = HashMap::new();
    query_params.insert("executionId".to_string(), execution_id);
    let resp = client
        .get(&*DOWNLOAD_EP)
        .header("Authorization", format!("ApiKey {}", api_key))
        .query(&query_params)
        .send()
        .expect("Failed to send request for download status");
    let status = resp.status();
    if status == StatusCode::ACCEPTED {
        Status::Processing
    } else if status == StatusCode::OK {
        let json: serde_json::Value = resp.json().expect("Failed to parse JSON for download status");
        let value = json["downloadUrl"].as_str().expect("Missing 'downloadUrl' in response");
        Status::Ready(value.to_string())
    } else {
        panic!("Unexpected status code when getting download status: {}", status);
    }
}
/// Downloads the obfuscated file from the presigned URL.
///
/// # Arguments
///
/// * `download_url` - The presigned URL returned by [`download`] when ready.
/// * `client` - A preconfigured `reqwest::blocking::Client`.
///
/// # Returns
///
/// The obfuscated file bytes.
///
/// # Panics
///
/// Panics if the download fails or the server responds with a non-success status, with a descriptive message.
pub fn download_obfuscated_file(
    download_url: &str,
    client: &Client,
) -> Vec<u8> {
    let response = client.get(download_url).send().expect("Failed to send request to download obfuscated file")
        .error_for_status().expect("Non-success status when downloading obfuscated file");
    let bytes = response.bytes().expect("Failed to read bytes from download response");
    bytes.to_vec()
}